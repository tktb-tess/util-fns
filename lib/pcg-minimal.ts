import type { RandomGenerator } from './random';
import { rot32 } from './math';

/** シードなし時の静的初期化定数 */
const pcg_initial_state = [0x853c49e6748fea9bn, 0xda3e39cb94b95bdbn] as const;

const pcg_multiplier = 0x5851f42d4c957f2dn;

/**
 * PCG-XSH-RR (Permuted congruential generator)
 */
export class PCGMinimal implements RandomGenerator {
  /**
   * length = 2, `[state, increment]`
   */
  readonly #state: BigUint64Array<ArrayBuffer>;

  static readonly name = 'PCGMinimal';
  readonly [Symbol.toStringTag] = PCGMinimal.name;

  /**
   * returns seed for constructing `PCGMinimal` instance
   * @returns random seed `BigUint64Array` with length 2
   * @example
   * const rng = new PCGMinimal(PCGMinimal.getSeed())
   */
  static getSeed() {
    return crypto.getRandomValues(new BigUint64Array(2));
  }

  /**
   * @param seeds
   * `BigUintArray` with length 2. \
   * if it is not given, initialized by default value
   * @example
   * // the following example is always initialized by the same seeds.
   * // it's not recommended
   * const weakRng = new PCGMinimal();
   *
   * // you should construct with random seeds generated by `PCGMinimal.getSeed()`.
   * const betterRng = new PCGMinimal(PCGMinimal.getSeed());
   */
  constructor(seeds?: BigUint64Array<ArrayBuffer>) {
    if (seeds && seeds.length >= 2) {
      this.#state = new BigUint64Array(2);
      this.#state[1] = (seeds[1] << 1n) | 1n;
      this.#step();
      this.#state[0] = seeds[0];
      this.#step();
    } else {
      this.#state = BigUint64Array.from(pcg_initial_state);
    }
  }

  /** step inner state */
  #step() {
    this.#state[0] = this.#state[0] * pcg_multiplier + this.#state[1];
  }

  /** 32bit 乱数を返す (内部状態は変わらない) */
  get #value() {
    const prev = this.#state[0];
    const rot = Number(prev >> 59n);
    const shifted = Number(BigInt.asUintN(32, (prev ^ (prev >> 18n)) >> 27n));
    return rot32(shifted, rot);
  }

  /**
   *
   * @returns a random 32-bit unsigned integer
   */
  getU32Rand() {
    this.#step();
    return this.#value;
  }

  /**
   * @returns a random 32-bit unsigned integer less than `bound`
   */
  getBoundedU32Rand(bound: number) {
    /** 32bit 上限 */
    const limit = 0x100000000;

    if (bound > limit) throw Error('`bound` exceeded limit (2^32)');

    const threshold = limit % bound;

    while (true) {
      const r = this.getU32Rand();
      if (r >= threshold) return r % bound;
    }
  }

  /**
   *
   * @param step the number of needed random integers
   * @param bound upper limit
   * @returns
   * the iterator that generates random 32-bit unsigned integers `step` times \
   * if `bound` is given, random integers are less than `bound`
   */
  *genU32Rands(step: number, bound?: number) {
    for (let i = 0; i < step; i++) {
      yield typeof bound === 'number'
        ? this.getBoundedU32Rand(bound)
        : this.getU32Rand();
    }
  }
}
