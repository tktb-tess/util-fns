const n=(n,t)=>{if(n.length!==t.length)return!1;for(let r=0;r<n.length;r++)if(n[r]!==t[r])return!1;return!0},t=n=>new Promise(t=>{setTimeout(()=>{t()},n)}),r=n=>(...t)=>()=>n(...t),e=n=>{const t=[];let r=[],e="",o=!1;for(let i=0;i<n.length;i++){const s=n[i];'"'!==s||0!==i&&"\\"===n[i-1]?","!==s||o?"\n"!==s||o?e+=s:(r.push(e.trim()),t.push(r),r=[],e=""):(r.push(e.trim()),e=""):o=!o}return r.push(e.trim()),t.push(r),t},o=async(n,t)=>{const r=Buffer.from(n,"utf8");return crypto.subtle.digest(t,r).then(n=>Buffer.from(n))},i=n=>{let t=n.toString(16);return 1&t.length&&(t="0"+t),Buffer.from(t,"hex")},s=n=>{const t=n.toString("hex")||"00";return BigInt("0x"+t)},u=(n,t)=>Math.floor(Math.random()*(t-n)+n),f=(n,t)=>{const r=n%t;return r<0n?r+t:r},a=(...n)=>n.map(n=>BigInt(n)),g=(n,t=!1)=>{if(!Number.isFinite(n))throw Error("`length` is not a valid number");if(n<=0)throw Error("`length` must be positive");const r=Math.ceil(n/32),e=crypto.getRandomValues(new Uint32Array(r));let o=Array.from(e,n=>n.toString(2).padStart(32,"0")).join("");return o=o.slice(0,n),t&&(o=o.replace(/^./,"1")),BigInt("0b"+o)},h=(n,t)=>{if(n>=t)throw Error("RangeError");const r=t-n,e=r.toString(2).length;return n+(()=>{for(let n=0;n<1e5;n++){const n=g(e);if(n>=c(2n,BigInt(e),r))return n%r}throw Error("Failed to generate a random bigint")})()},c=(n,t,r)=>{if(r<1n)throw Error("`mod` must be positive");if(t<0n)throw Error("`power` must not be negative");for(;n<0n;)n+=r;if(1n===r)return 0n;if(n%r===1n||n%r===0n)return n;if(n===r-1n)return 1n&t?r-1n:1n;let e=1n;for(;t>0n;)1n&t&&(e=e*n%r),n=n*n%r,t>>=1n;return e},l=(n,t)=>{if(0n===n&&0n===t)return{x:0n,y:0n,gcd:0n};if(0n===n)return t>0n?{x:0n,y:-1n,gcd:t}:{x:0n,y:1n,gcd:-t};if(0n===t)return n>0n?{x:1n,y:0n,gcd:n}:{x:-1n,y:0n,gcd:-n};let[r,e,o]=[1n,0n,n],[i,s,u]=[0n,-1n,t];for(;;){const n=o/u,t=o-n*u;if(0n===t)break;[r,i]=[i,r-n*i],[e,s]=[s,e-n*s],[o,u]=[u,t]}return u<0n&&(i*=-1n,s*=-1n,u*=-1n),{x:i,y:s,gcd:u}},d=n=>{if(n<0n)throw Error("'n_' must be non-negative");if(0n===n)return 1n;const t=(n,r)=>{if(n>=r)return 1n;const e=(r-n)/2n;if(BigInt((r-2n).toString(2).length)*e<63n){let t=n;for(let e=n+2n;e<r;e+=2n)t*=e;return t}const o=n+e|1n;return t(n,o)*t(o,r)},r=n-BigInt(n.toString(2).match(/1/g)?.length??0),e=(n=>{let r=3n,e=1n,o=1n;for(let i=BigInt(n.toString(2).length)-1n-1n;i>-1n;--i){const s=1n+(n>>i)|1n;o*=t(r,s),r=s,e*=o}return e})(n);return e<<r},m=(n,t)=>BigInt.asUintN(32,n>>(31n&t)|n<<(31n&-t)),b=(n,t)=>n>>>(31&t)|n<<(31&-t),p=(n,t)=>{if(t<1n||t%2n==0n)throw Error("`n` is invalid");for(;n<0n;)n+=t;n%=t;let r=1n;for(;0n!==n;){for(;n%2n==0n;){n/=2n;const e=t%8n;3n!==e&&5n!==e||(r*=-1n)}[n,t]=[t,n],n%4n==3n&&t%4n==3n&&(r*=-1n),n%=t}return 1n===t?r:0n},w=n=>{if(n<0n)return!1;if(0n===n)return!0;let t=1n,r=n;for(;t+1n<r;){const e=(t+r)/2n;e**2n<n?t=e:r=e}return n===t**2n||n===(t+1n)**2n},y=[0x853c49e6748fea9bn,0xda3e39cb94b95bdbn];class B{#n=new BigUint64Array(2);get[Symbol.toStringTag](){return B.name}static getSeed(){return crypto.getRandomValues(new BigUint64Array(2))}constructor(n){n&&n[0]&&n[1]?(this.#n[1]=n[1]<<1n|1n,this.step(),this.#n[0]=n[0],this.step()):(this.#n[0]=y[0],this.#n[1]=y[1])}step(){this.#n[0]&&this.#n[1]&&(this.#n[0]=6364136223846793005n*this.#n[0]+this.#n[1])}get value(){const n=this.#n[0];if(!n)throw Error("empty state");const t=n>>59n,r=BigInt.asUintN(32,(n^n>>18n)>>27n);return b(Number(r),Number(t))}getRand(){return this.step(),this.value}getBoundedRand(n){const t=4294967296;if(n>t)throw Error("bound exceeded limit (2^32)");const r=t%n;for(;;){const t=this.getRand();if(t>=r)return t%n}}async*genRands(n,t){for(let r=0;r<n;r++)yield t?this.getBoundedRand(t):this.getRand()}}const E=(n,t)=>f(1n==(1n&n)?n+t>>1n:n>>1n,t),x=(n,t,r,e)=>{if(n%2n!=1n)throw Error("`n` must be odd");let o=n+1n,i=0n;for(;o%2n==0n;)o>>=1n,i+=1n;const[s,u]=((n,t,r,e)=>{let o=1n,i=r;const s=n.toString(2).slice(1);for(const n of s)[o,i]=[f(o*i,t),E(i*i+e*o*o,t)],"1"===n&&([o,i]=[E(r*o+i,t),E(e*o+r*i,t)]);return[o,i]})(o,n,r,t);let a=u;if(0n===s)return!0;e=c(e,o,n);for(let t=0n;t<i;t++){if(0n===a)return!0;a=f(a*a-2n*e,n),e=c(e,2n,n)}return!1},S=n=>{if(n<=1n)return!1;if(n%2n==0n)return 2n===n;const t=[2n,3n,5n,7n,11n,13n,17n,19n,23n,29n,31n,37n,41n,43n,47n,53n,59n,61n,67n,71n,73n,79n,83n,89n,97n,101n];for(const r of t)if(n%r===0n)return n===r;if(!(n=>{if(n<=1n)return!1;if(n%2n==0n)return 2n===n;let t=n-1n,r=0n;for(;t%2n==0n;)t>>=1n,r+=1n;const[e,o]=[t,r];let i=c(2n,e,n);if(1n===i)return!0;for(let t=0n;t<o;t++){if(i===n-1n)return!0;i=i*i%n}return!1})(n))return!1;const[r,e]=(n=>{let t=5n,r=p(t,n);for(;r>0n;){if(t=t>0n?t+2n:t-2n,t*=-1n,-15n===t&&w(n))return[0n,0n];r=p(t,n)}return[t,r]})(n);if(0n===e)return!1;return x(n,r,1n,(1n-r)/4n)},I=(n,t)=>{if(t<2n)throw Error("noPrimesFound");for(let r=0;r<1e5;r++){const r=h(n,t);if(S(r))return r}throw Error("noPrimesFound")},R=(n,t=!1)=>{if(n<2)throw Error("noPrimesFound");for(let r=0;r<1e5;r++){const r=g(n,t);if(S(r))return r}throw Error("noPrimesFound")};export{i as BItoBuffer,B as PCGMinimal,S as bailliePSW,s as bufferToBI,l as exEuclidean,d as factorial,o as getHash,g as getRandBIByBitLength,h as getRandBIByRange,R as getRandPrimeByBitLength,I as getRandPrimeByRange,u as getRndInt,n as isEqArray,w as isSquare,p as jacobiSymbol,r as lazify,c as modPow,e as parseCSV,f as residue,b as rot32,m as rot32BI,t as sleep,a as toBigInt};
//# sourceMappingURL=main.js.map
